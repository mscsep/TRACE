---
title: "Datapreparation TRACE dataset"
author: "Valeria Bonapersona & Milou Sep"
date: "March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---


# Preparation of the environment
```{r setup}
rm(list = ls()) #clean environment
# libraries
library(metafor) # for effect size estimation
library(dplyr) #for general functions
library(osfr)
library(readxl)
```

## import data files 
```{r}
 data<-readRDS("processed_data/TRACErecoded.RDS") # contains only included, recoded, data 
 #data <- read.csv("processed_data/TRACEmerged.csv", sep = ";", dec = c(",", ".")) # Data

 osf_retrieve_file("a6dmj") %>% osf_download(path = "data", conflicts="overwrite") # search 3
 method <- read_excel("data/TRACE_method_codes.xlsx", sheet = "codes")
# method <- read.csv("TRACE_method_codes.csv", sep = ";", na.strings = c(" ", "-"), dec = c(",", ".")) # Method codes

 method %>% select(!notes) %>% filter(is.na(.)) # check, should be no missing.

```


## **Select relevant colums dataset**

```{r}
method %>% select(task, measure, type, phase, valence, recode, cuectx) -> method 
# Create reference var as character
df1<-data %>% mutate(reference = as.character(paste(author, year, sep=" "))) %>% select(-c(author, year)) # Merge year & author & dropvars.

```



## **Add method codes to data**
NB the combination of task and measure indicates which method is used to measure behavior. Those values are combined into a new variable ..
```{r}
df1 %>% mutate(measureID = as.factor(paste(task, measure, sep="."))) -> df3
method %>% mutate(measureID = as.factor(paste(task, measure, sep="."))) -> method1
#' ... that is used to merge data and method codes
# df4<- merge(df3, method1, by="measureID", all=T, suffixes = c("_d", "_m"))

left_join(df3,method1, by="measureID", suffix = c(".d", ".m"))->df4

# glimpse(df4)

#' Quality check after merging.. (should be identical)
 identical(as.character(df4$task.d), as.character(df4$task.m))
 identical(as.character(df4$measure.d), as.character(df4$measure.m))
# dat %>% select(-c(task_m, measure_m)) -> dat #remove duplicate colums (niet echt nodig...)


```

# Check missing values
```{r}
which(is.na(df4$subject.cat))
```


```{r}
which(is.na(df4$PMID))
```


```{r}
which(is.na(df4$comparison))
```


# recode measure, PTSD type and population
```{r}

# df4$subject.cat

# df4.1 %>% select(subject.cat, measure.d, measure2, ptsd.type, ptsd.type2, population, population2) %>% View()


df4 %>% mutate(
  measure2 = case_when(
    # measure
    (subject.cat == "Animal") & grepl("freezing", measure.d, ignore.case = T) ~ "freezing",
    (subject.cat == "Animal") & grepl("latency|exploration|time|entrie|avoidance|cross|error|DR|DI", measure.d, ignore.case = T) ~ "exploration",
    (subject.cat == "Animal") & grepl("Object", measure.d, ignore.case = T) ~ "manipulation",
    # human
    (subject.cat == "Human") & grepl("EMG|SCR", measure.d, ignore.case = T) ~ "physiology",
    (subject.cat == "Human") & !grepl("EMG|SCR", measure.d, ignore.case = T) ~ "non-physiology"),
  # PTSD type
  # ptsd.type2 = ifelse(grepl("Mixed", ptsd.type, fixed = T), "Mixed", as.character(ptsd.type)),
  
  ptsd.type2 = case_when(
    (subject.cat == "Human") & grepl("Mixed", ptsd.type, fixed = T) ~ "Mixed",
    (subject.cat == "Animal") & (grepl("+", ptsd.type, fixed=T) #| grepl("SPS", ptsd.type, fixed=T)
                                 ) ~ "Mixed",
    TRUE ~ as.character(ptsd.type)),
  
  # Population
  population2 = case_when(
    #human
    (subject.cat == "Human") & grepl("Veterans", population, fixed = T) ~ "Veterans",
    (subject.cat == "Human") & grepl("Civilian", population, fixed = T) ~ "Civilian",
    (subject.cat == "Human") & grepl("Refugee", population, fixed = T) ~ "Civilian",
    #animals
    (subject.cat == "Animal") & grepl("C57BL/6", population, fixed = T) ~ "C57BL/6",
    (subject.cat == "Animal") & grepl("Charles Foster", population, fixed = T) ~ "Charles Foster",
    (subject.cat == "Animal") & grepl("Wistar", population, fixed = T) ~ "Wistar",
    TRUE ~ as.character(population))) %>%
    # mutate(
    #   ptsd.type2= as.factor(ptsd.type2),
    #   population2= as.factor(population2)) %>% 
    droplevels()->df4.1

# # for checking
# df4.1 %>% 
#   filter(subject.cat == "Human") %>%
#     filter(subject.cat == "Animal") %>%
#   # filter(is.na(measure2)) %>%
#   select(task.d, valence, phase, measure.d, measure2) %>% 
#   # distinct(measure.d) %>%
#    View()
```


#' **Set variable properties**
```{r}
new_factor_names <-c("ptsd.type2", "population2","task.d", "measure.d", "measure2", "type", "phase", "valence", "cuectx")
# numeric_names <- c("nPTSD", "nHC", "meanPTSD", "sdPTSD", "semPTSD", "meanHC", "sdHC", "semHC", "recode")

 # df4 %>% select(numeric_names) %>% str()
#' # update 9.4 ik denk dat dit niet meer nodig is.. omdat de numeric al numeric zijn
#' for(i in 1:length(numeric_names)){
#'   df5[,numeric_names[i]]<- sub("-", "-", as.character(df5[,numeric_names[i]]), fixed = TRUE) # Correction of - signs
#'   df5[,numeric_names[i]]<- as.numeric(sub(",", ".", as.character(df5[,numeric_names[i]]), fixed = TRUE))
#' }

df4.1 %>% 
  # mutate_at(.vars=numeric_names, as.numeric) %>% 
  mutate_at(.vars=new_factor_names, factor) ->df6
 # str(df6)
```




# **correct ID coding PTSD and HC groups**
If part of the subjects in a experimental/control group is reused, this group must get the same identification code as the complete group (otherwise groups get incorrect unique codes in the analyses). In datafiles currently:

 - [ ] exp & control ID -> als sub group gebruikt is moet die dezelfde code als de totale group hebben, anders krijgen ze unique codes in de analyses (en dat is incorrect ivm nesting)
 - [ ] in S3 correct
 - [ ] animal two exp groups together: "exp ID 355+347"
 - [x] in human all correct
 - [ ] in S1 en S2 heb ik steeds 'part of..' opgeschreven
 - [ ] pas aan in r in S2 animal:
   - [ ] in exp ID: "part of #" en controlID_#
 - [ ] in control ID: "part of #" en "part of exp ID #"
 - [x] s2 human NA
 - [ ] s1 :
   - [ ] in exp ID: "part of #" en ControlID_#
 - [ ] in control ID: "part of exp ID #"
```{r}
df6 %>% mutate(idPTSD = sub("part of ", "",idPTSD, fixed = TRUE),
               idHC = sub("part of ", "",idHC, fixed = TRUE)) ->df7
```

            
# **Correction for multiple use control group**

 Merge ID's of experimental and control groups.
```{r}
df8 <- df7 %>% mutate(id_combination = as.factor(paste(idPTSD, idHC, sep=".")))
# str(df8)
# for checking (should be NA, if both missing excluded in dataset)
df8 %>% filter(is.na(semPTSD) & is.na(sdPTSD)) #%>% View()
df8 %>% filter(is.na(semHC) & is.na(sdHC)) #%>% View()
```

 Check which control groups are used multiple times
```{r}
reused_controls <- df8 %>%
  select(idPTSD, idHC, id_combination)%>%
  group_by(idHC) %>% #for each control groups
  summarise (used=length(unique(id_combination)))%>%  # count the amount of unique id combinations
  filter(used>1) # show control groups in which a unique combination is precent more than once
reused_controls # 10 control groups are used in multiple unique id_combinations # 18.3.19 11 control grousp used multiple times # 8.4.21 66 are reused
#' Check results
#+ eval=F
df8 %>% filter(idHC%in%reused_controls$idHC) %>% tibble
#' add to dataframe
df8$used<- ifelse(df8$idHC%in%reused_controls$idHC, reused_controls$used, NA )
#' Recalculate n's
df8$nHC_corrected<-ifelse(!is.na(df8$used), df8$nHC/df8$used, df8$nHC)
#' Check if the effects are correct.. yes
df8 %>% 
  filter(idHC %in% reused_controls$idHC)  %>% 
  select(nHC, nHC_corrected, used) %>% head()
#' round
df8$nHC<-round(df8$nHC_corrected)
```




#' **Calculate SD from SEM**
```{r}
df8$sdPTSD <- ifelse(is.na(df8$sdPTSD), (df8$semPTSD * sqrt(df8$nPTSD)), df8$sdPTSD)
df8$sdHC <- ifelse(is.na(df8$sdHC), (df8$semHC * sqrt(df8$nHC)), df8$sdHC)
```



#' **Check Missing values (should be none)**
```{r}
#' Sample sizes ok
which(is.na(df8$nPTSD))
which(is.na(df8$nHC))
#' sd ok
which(is.na(df8$sdPTSD))
which(is.na(df8$sdHC))

#' #' Missing values SD? Original datafile checked: 5 papers don't report sem or sd: PMID: 7654154, 8731522, 9821567, 17392739, 27297027
#' unique(df8[which(is.na(df8$sdHC)),"PMID"]) 
#' #' Theses values correspond with original datafile, and are exlcuded from further analysis
#' dat %>% filter(!is.na(sdC)) -> dat
df8 %>% select(-c(semPTSD, semHC, used, nHC_corrected)) -> df9 # Remove unnessesary colums

#' Missingvalues are checked again, should be non.. # update 8.4.21 -> there are missings.. as shock, time res.sus split are still in data
# which(is.na(df9)) 

df9 %>% select(!c("shocks.num", "shocks.amp", "time","res.sus.split")) %>% filter(!(is.na(.))) %>% nrow() # is idem als total  (=1643)

#' update 19.3.19: na toevoeging "keyfinding", sommmige na, anders niet.
# head(is.na(df9)) 
```

#' **Calculation of effect sizes and checks**
```{r}
df10 <- escalc(
  m1i = meanPTSD, sd1i = as.numeric(sdPTSD), n1i = nPTSD, 
              m2i = meanHC, sd2i = as.numeric(sdHC), n2i = nHC, 
              measure = "SMD", #method = "HE",  # calc hedge's G
              data = df9)
```

#' **Recode Effect sizes in same direction (higher score = better performance)**
```{r}
#' Based on recode variable, which is specified in "Trace_methode_codes.csv"
df10$yi <- df10$yi * df10$recode
#' INTERPRETATION: Viechtbauer, W. (2010). Conducting Meta-Analyses in R with the metafor Package. Journal of Statistical Software, 1â€“48. Page 7
#' "SMD": The standardized mean difference is equal to (m1i m2i)/spi
#' In the calulations above 1 = ptsd en 2 = control; therefore positive effect size = PTSD more, negative effectsize is HC more 

```

#' **add unique id's**
```{r}
df10$each <- c(1:nrow(df10)) 
```


#' **Explore frequencies of potential moderators** 
#' Potential moderators in dataset: (NB valence, phase, cuectx follow from task & measure in dataset (see code above)):
#' - comparisionControl: CODES: A="ptsd_nontrauma_H", B="trauma_nontrauma_H", C="ptsd_trauma_H", 
#' D="trauma_nontrauma_A", E="ptsd_nontrauma_A",F="ptsd_trauma_A"
#' - valence # NB codes: # T=trauma; N=non_trauma_neutral; E=non_trauma_emotional; F=non-trauma_fearfull
#' - phase: L=learning or M=memory (or E=extinction) (THINK:--> extinction droppen / indelen bij learing?)
#' - cuectx: cue or context

#' NB for the analysis 2 moderator possible.
```{r}
 df10 %>% filter(is.na(valence)) %>% select(PMID, task.d, measure.d, task.m, measure.m) %>% head()
```



#'*Comparison and subject as moderators?*
```{r}
df10 %>% group_by(subject.cat, valence, comparison) %>%
  summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% data.frame() %>% write.csv2("results/inclusions.by.comparisons.valence.csv") # to save
#' Not enough datapoints in some categories --> not possible

#' NB If comparisontypes is no longer included in analyses, comparision B needs to be excluded 
#' (in which healhty trauma exposed humans are compared to heathy non-trauma exposed humans; so NO PTSD patients)
# dat %>% filter(comparisonControl != c("B")) %>% droplevels() -> dat

```



#' *Valence and subject as moderators?*
```{r}
df10 %>% group_by(subject.cat, valence) %>%
summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% data.frame() %>% write.csv2("results/inclusions.by.valence.csv") 
#' Problems with distribution valence categories in animal & human data, not al valence categories are in human & animal.
#' Decided to group stressful vs non-stressful learning
df10$Valence_Grouped <- ifelse(df10$valence %in% c("T","F","E"), "stress", "neutral") #NB nu trauma ook bij stressed!
df10$Valence_Grouped <-as.factor(df10$Valence_Grouped)
df10 %>% select(task.d, Valence_Grouped, valence) # to check. 
#' NB Learning & memory of "Trauma" information are never measured in human (with behavioral tasks), therefor not an 'fair' comparison between animal & human..
#' Consider exclusion in 'analysis script'

```


 
#' *Phase and subject as moderators?*
```{r}
# Explore distribution learning and memory data per subject & valence type
df10 %>% 
  group_by(subject.cat, Valence_Grouped, phase, cuectx) %>%
  summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% write.csv2("results/inclusions.by.phase.cuectx.csv")
#' NB extinction data is not available for all groups. Besides it is an specific for of fear learning..
#' Consider exclusion in 'analysis script'
```



#' *cuectx and Valence as moderators, Animal & Human separate?*
```{r}
df10 %>% 
  group_by(subject.cat, Valence_Grouped, cuectx) %>%
  summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% write.csv2("results/inclusions.by.cuectx.csv") 
```



#' *Phase and Valence, in animal human separately?*
```{r}
df10 %>% 
  group_by(subject.cat, Valence_Grouped, phase) %>%
  summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% write.csv2("results/inclusions.by.phase.csv") 


df10 %>% group_by(subject.cat, phase, valence) %>%
  summarize(papers=length(unique(PMID)), comparisons=length(each)) %>% data.frame() %>% write.csv2("results/inclusions.by.phase.valence.csv")

# dat %>% filter(subject == "Animal", Valence_Grouped == "neutral", phase=="L")
# dat %>% filter(subject == "Animal", Valence_Grouped == "neutral", phase=="M")

```




# Save resulting dataset --------------------------------------------------
```{r}
df11 <- df10 %>% droplevels() #drop missing levels & Remove 'unique id combination' variable (not needed anymore)

#str(dat)

saveRDS(df11, file = "processed_data/TRACEprepared.RData") #save
```
